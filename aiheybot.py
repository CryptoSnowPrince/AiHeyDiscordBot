import discord
import sys
import requests
import io
import asyncio
import keyboards
import string
import time
import replicate
import os
from decouple import config

import myconfig
import messages

os.environ['REPLICATE_API_TOKEN'] = config('REPLICATE_API_TOKEN')

replicate_token = config('REPLICATE_TOKEN')

client = discord.Client(intents=discord.Intents.all())
PREFIX = "/hey"

@client.event
async def on_ready():
    for guild in client.guilds:
        if guild.name == config("DISCORD_GUILD"):
            break
    print(
        f'{client.user} is connected to the following guild:\n'
        f'{guild.name}(id: {guild.id})'
    )



@client.event
async def on_message(message):
    print (message.content);
    
    for guild in client.guilds:
        if guild.name == config("DISCORD_GUILD"):
            break

    if message.author == client.user:
        return

    if message.content.startswith(PREFIX + " "):
        await handle_input (message)

async def handle_input(message):
    prompt = message.content.split(PREFIX + " ")[1]
    if prompt.strip() == "":
        return

    username = message.author.id
    origin_username = username if username else "none"
    # if not username:
    #     username = str(time.time)

    # if username in comps.keys() and (time.time() - comps[username]) < 40:
    #     await pending(message, username, origin_username)
    #     return
    # comps[username] = time.time()
    model = replicate.models.get("stability-ai/stable-diffusion")

    version = model.versions.get(
        "f178fa7a1ae43a9a9af01b833b9d2ecf97b1bcb0acfd2dc5dd04895e042863f1")

    # https://replicate.com/stability-ai/stable-diffusion/versions/f178fa7a1ae43a9a9af01b833b9d2ecf97b1bcb0acfd2dc5dd04895e042863f1#input
    inputs = {
        'width': 768,
        'height': 768,
        'prompt_strength': 0.8,
        'num_outputs': 1,
        'num_inference_steps': 50,
        'guidance_scale': 7.5,
        'scheduler': "DPMSolverMultistep",
    }
    inputs['prompt'] = prompt
    wait_m = await message.channel.send(messages.message["/wait"])
    prediction = replicate.predictions.create(version=version, input=inputs)
    tm = 40
    output = []
    old_percent_m = ""
    while tm > 0:
        prediction.reload()

        if prediction.status == "failed":
            break
        percent = prediction.logs.split("\n")[-1].split("|")[0]
        percent_m = ""
        if percent:
            percent_m = percent
        if percent_m != old_percent_m:
            # await wait_m.edit_text("Processing request from @" + origin_username + " | " + prompt + " | " + percent_m)
            pass
        old_percent_m = percent_m
        if prediction.status == 'succeeded':
            output = prediction.output
            break
        await asyncio.sleep(5)
        tm -= 5

    if len(output) == 0:
        # await wait_m.edit_text("Try running it again, or try a different prompt")
        return
    generated_image_url = output[0]
    print (generated_image_url)
    tick = time.time()
    # water_mark(generated_image_url, username)
    # water_mark("https://replicate.delivery/pbxt/F8TMwQbpjfVpTiV395NNfDn38ymXEzf1yeePeGMU1T45h9AHE/out-0.png")
    # photo = open(f"images/{username}_watermarked.png", 'rb')
    await wait_m.delete()
    Buy = "https://pancakeswap.finance/swap"
    Telegram = "https://t.me/AiHeyOfficial"
    Website = "https://aihey.co"
    caption = f"{prompt}\nimage generated by @{origin_username}\n\n• <a href ='{Telegram}'>Join AiHey</a> | <a href ='{Website}'>Website</a> | <a href ='{Buy}'>BUY IMAGE</a> •"
    response = requests.get(generated_image_url)
    image = response.content
    await message.channel.send(file=discord.File(io.BytesIO(image), 'image.jpg'))

print (config('TOKEN'))
client.run(config('TOKEN'))